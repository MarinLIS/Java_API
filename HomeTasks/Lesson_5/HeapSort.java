// package HomeTasks.Lesson_5;

// import java.util.Arrays;

// /*
//  * Сортировка массива с использованием кучи

// Необходимо разработать программу для сортировки массива целых чисел 
// с использованием сортировки кучей (Heap Sort). 
// Программа должна работать следующим образом:

// Принимать на вход массив целых чисел для сортировки. 
// Если массив не предоставлен, программа использует массив по умолчанию.

// Сначала выводить исходный массив на экран.

// Затем применять сортировку кучей (Heap Sort) для сортировки элементов массива 
// в порядке возрастания.

// Выводить отсортированный массив на экран.

// Ваше решение должно содержать два основных метода: buildTree, 
// который строит сортирующее дерево на основе массива, и heapSort, 
// который выполняет собственно сортировку кучей. Основная часть кода предоставлена вам.

// Программа должна быть способной сортировать массив, даже если он состоит из 
// отрицательных чисел и имеет дубликаты.

// На входе:

// '5 8 12 3 6 9'
// На выходе:


// Initial array:
// [5, 8, 12, 3, 6, 9]
// Sorted array:
// [3, 5, 6, 8, 9, 12]
// В этой программе:

// Метод buildTree строит сортирующее дерево на основе массива.
// Метод heapSort выполняет собственно сортировку кучей.
// Метод leftChild является вспомогательным методом, который используется 
// для получения индекса левого потомка узла.
// Вместо метода heapify, мы используем цикл в методе buildTree для преобразования 
// поддерева в двоичную кучу. Это достигается путем сравнения родительского узла с его 
// потомками и обмена их местами, если потомок больше родителя. Этот процесс повторяется, 
// пока не будет достигнут конец кучи или пока родительский узел не станет больше обоих 
// своих потомков. Затем мы переходим к следующему узлу и повторяем процесс. 
// Это обеспечивает, что каждый родительский узел больше своих потомков, что является 
// ключевым свойством двоичной кучи.
// В методе heapSort, после каждого обмена корневого элемента с последним элементом в 
// куче, мы вызываем buildTree для оставшейся части кучи. Это гарантирует, что после 
// каждого обмена новый корневой элемент является наибольшим элементом в куче, что 
// является необходимым условием для сортировки кучей.
// Таким образом, эта программа выполняет сортировку кучей без явного использования 
// метода heapify. Однако функциональность heapify все равно реализована внутри метода 
// buildTree.
//  */

// public class HeapSort {
//     public static void buildTree(int[] tree, int sortLength) {
//         // Введите свое решение ниже

//         for (int i = sortLength / 2 - 1; i >= 0; i--) {
//             int parent = i;
//             int child;
//             int temp;

//             for (temp = tree[i]; leftChild(parent) < sortLength; parent = child) {
//                 child = leftChild(parent);

//                 if (child != sortLength - 1 && tree[child] < tree[child + 1]) {
//                     child++;
//                 }

//                 if (temp >= tree[child]) {
//                     break;
//                 }

//                 tree[parent] = tree[child];
//             }
//             tree[parent] = temp;
//         }
     
//     }

//     public static void heapSort(int[] sortArray, int sortLength) {
//      // Введите свое решение ниже
//         buildTree(sortArray, sortLength);

//         for (int i = sortLength - 1; i > 0; i--) {
//             int temp = sortArray[0];
//             sortArray[0] = sortArray[i];
//             sortArray[i] = temp;

//             buildTree(sortArray, i);
//         }
//     }

//     private static int leftChild(int i) {
//         return 2 * i + 1;
//     }
// }
